---
timestamp: 'Sat Oct 18 2025 22:04:16 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251018_220416.9be27a9e.md]]'
content_id: d284bce12a84ccbd39d3a381458bc74f6fb562f3482fd66ab61ba6bf384cf3d8
---

# Test File for Problem Concept

```typescript
// file: src/concepts/Problem/ProblemConcept.test.ts

import { assertEquals, assertExists, assertInstanceOf, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { ID } from "@utils/types.ts";
import ProblemConcept from "./ProblemConcept.ts";

Deno.test("Problem Concept Tests", async (t) => {
  const [db, client] = await testDb();
  const problemConcept = new ProblemConcept(db);

  // Define some reusable test IDs
  const boardAId: ID = "board:trainingBoardA" as ID;
  const boardBId: ID = "board:compWallB" as ID;
  const userAliceId: ID = "user:Alice" as ID;
  const userBobId: ID = "user:Bob" as ID;

  await t.step("Test: createProblem - successful creation", async () => {
    console.log("\n--- Testing createProblem (Success) ---");
    const result = await problemConcept.createProblem({
      name: "Crimpy Traverse",
      grade: "V7",
      holds: ["H1", "H5", "H10", "H11", "H15"],
      movementTypes: ["crimp", "traverse"],
      board: boardAId,
      setter: userAliceId,
    });

    console.log("Result:", result);
    assertNotEquals((result as { error: string }).error, undefined, "Should not return an error.");
    assertExists((result as { problem: ID }).problem, "Should return a problem ID.");

    const createdProblemId = (result as { problem: ID }).problem;

    // Verify the problem exists and has correct attributes by querying the board
    const problemsOnBoardA = await problemConcept.getProblemsByBoard({
      board: boardAId,
    });
    assertNotEquals((problemsOnBoardA as { error: string }).error, undefined, "getProblemsByBoard should not return an error.");
    assertEquals(
      (problemsOnBoardA as { problems: any[] }).problems.length,
      1,
      "There should be one problem on boardA.",
    );
    const problem = (problemsOnBoardA as { problems: any[] }).problems[0];
    assertEquals(problem._id, createdProblemId, "Problem ID should match.");
    assertEquals(problem.name, "Crimpy Traverse", "Problem name should match.");
    assertEquals(problem.grade, "V7", "Problem grade should match.");
    assertEquals(problem.holds, ["H1", "H5", "H10", "H11", "H15"], "Problem holds should match.");
    assertEquals(problem.movementTypes, ["crimp", "traverse"], "Problem movementTypes should match.");
    assertEquals(problem.board, boardAId, "Problem board should match.");
    assertEquals(problem.setter, userAliceId, "Problem setter should match.");
    console.log("Verification successful: Problem created and retrieved with correct details.");
  });

  await t.step("Test: createProblem - with optional movementTypes (empty)", async () => {
    console.log("\n--- Testing createProblem (Optional movementTypes) ---");
    const result = await problemConcept.createProblem({
      name: "Slabby Balancy",
      grade: "V3",
      holds: ["S1", "S2", "S3"],
      board: boardAId,
      setter: userBobId,
    });

    console.log("Result:", result);
    assertNotEquals((result as { error: string }).error, undefined, "Should not return an error.");
    assertExists((result as { problem: ID }).problem, "Should return a problem ID.");

    const problemsOnBoardA = await problemConcept.getProblemsByBoard({
      board: boardAId,
    });
    const problemCount = (problemsOnBoardA as { problems: any[] }).problems.length;
    assertEquals(problemCount, 2, "There should now be two problems on boardA.");
    const newProblem = (problemsOnBoardA as { problems: any[] }).problems.find(
      (p) => p.name === "Slabby Balancy",
    );
    assertEquals(newProblem.movementTypes, [], "movementTypes should default to an empty array.");
    console.log("Verification successful: Problem created with default empty movementTypes.");
  });

  await t.step("Test: createProblem - validation errors", async () => {
    console.log("\n--- Testing createProblem (Validation Errors) ---");
    const testCases = [
      {
        name: "",
        grade: "V1",
        holds: ["H1"],
        board: boardAId,
        setter: userAliceId,
        expectedError: "Problem name cannot be empty.",
      },
      {
        name: "Test Problem",
        grade: "",
        holds: ["H1"],
        board: boardAId,
        setter: userAliceId,
        expectedError: "Problem grade cannot be empty.",
      },
      {
        name: "Test Problem",
        grade: "V1",
        holds: [],
        board: boardAId,
        setter: userAliceId,
        expectedError: "Problem must have at least one hold position.",
      },
      {
        name: "Test Problem",
        grade: "V1",
        holds: ["H1"],
        board: "" as ID,
        setter: userAliceId,
        expectedError: "Problem must be associated with a board ID.",
      },
      {
        name: "Test Problem",
        grade: "V1",
        holds: ["H1"],
        board: boardAId,
        setter: "" as ID,
        expectedError: "Problem must have a setter (User ID).",
      },
    ];

    for (const tc of testCases) {
      console.log(`Testing invalid case: ${tc.expectedError}`);
      const result = await problemConcept.createProblem(tc);
      console.log("Result:", result);
      assertEquals(
        (result as { error: string }).error,
        tc.expectedError,
        `Expected error: ${tc.expectedError}`,
      );
      assertNotEquals(
        (result as { problem: ID }).problem,
        undefined,
        "Should not return a problem ID for invalid input.",
      );
    }
    console.log("Verification successful: createProblem handles validation errors correctly.");
  });

  await t.step("Test: getProblemsByBoard - retrieves correct problems", async () => {
    console.log("\n--- Testing getProblemsByBoard (Retrieval) ---");
    // Ensure the previous problems are there from earlier steps
    const problemsBoardA = await problemConcept.getProblemsByBoard({ board: boardAId });
    assertEquals((problemsBoardA as { problems: any[] }).problems.length, 2, "Expected 2 problems on boardA.");

    // Create a problem on a different board
    await problemConcept.createProblem({
      name: "Dyno Monster",
      grade: "V9",
      holds: ["D1", "D2"],
      movementTypes: ["dyno"],
      board: boardBId,
      setter: userAliceId,
    });

    const problemsBoardB = await problemConcept.getProblemsByBoard({ board: boardBId });
    console.log("Problems on Board B:", problemsBoardB);
    assertEquals((problemsBoardB as { problems: any[] }).problems.length, 1, "Expected 1 problem on boardB.");
    assertEquals(
      (problemsBoardB as { problems: any[] }).problems[0].name,
      "Dyno Monster",
      "Problem name on boardB should match.",
    );

    // Verify board A still has 2 problems
    const problemsBoardAAfterB = await problemConcept.getProblemsByBoard({ board: boardAId });
    assertEquals(
      (problemsBoardAAfterB as { problems: any[] }).problems.length,
      2,
      "Board A should still have 2 problems.",
    );
    console.log("Verification successful: getProblemsByBoard filters by board correctly.");
  });

  await t.step("Test: getProblemsByBoard - no problems found", async () => {
    console.log("\n--- Testing getProblemsByBoard (No Results) ---");
    const nonExistentBoardId: ID = "board:nonExistent" as ID;
    const result = await problemConcept.getProblemsByBoard({
      board: nonExistentBoardId,
    });
    console.log("Result for non-existent board:", result);
    assertEquals(
      (result as { problems: any[] }).problems.length,
      0,
      "Should return an empty array for a board with no problems.",
    );
    console.log("Verification successful: getProblemsByBoard returns empty for no match.");
  });

  await t.step("Test: getProblemsByBoard - validation errors", async () => {
    console.log("\n--- Testing getProblemsByBoard (Validation Errors) ---");
    const result = await problemConcept.getProblemsByBoard({ board: "" as ID });
    console.log("Result for empty board ID:", result);
    assertEquals(
      (result as { error: string }).error,
      "Board ID cannot be empty.",
      "Expected error for empty board ID.",
    );
    assertNotEquals(
      (result as { problems: any[] }).problems,
      undefined,
      "Should not return problems for invalid input.",
    );
    console.log("Verification successful: getProblemsByBoard handles validation errors.");
  });

  await t.step("Test: getProblemsByGrade - retrieves correct problems", async () => {
    console.log("\n--- Testing getProblemsByGrade (Retrieval) ---");
    // Problems created so far: V7, V3 (boardA), V9 (boardB)
    const resultV7 = await problemConcept.getProblemsByGrade({ grade: "V7" });
    console.log("Problems with Grade V7:", resultV7);
    assertEquals((resultV7 as { problems: any[] }).problems.length, 1, "Expected 1 problem with grade V7.");
    assertEquals(
      (resultV7 as { problems: any[] }).problems[0].name,
      "Crimpy Traverse",
      "Problem name should match.",
    );

    const resultV3 = await problemConcept.getProblemsByGrade({ grade: "V3" });
    console.log("Problems with Grade V3:", resultV3);
    assertEquals((resultV3 as { problems: any[] }).problems.length, 1, "Expected 1 problem with grade V3.");
    assertEquals(
      (resultV3 as { problems: any[] }).problems[0].name,
      "Slabby Balancy",
      "Problem name should match.",
    );

    const resultV9 = await problemConcept.getProblemsByGrade({ grade: "V9" });
    console.log("Problems with Grade V9:", resultV9);
    assertEquals((resultV9 as { problems: any[] }).problems.length, 1, "Expected 1 problem with grade V9.");
    assertEquals(
      (resultV9 as { problems: any[] }).problems[0].name,
      "Dyno Monster",
      "Problem name should match.",
    );
    console.log("Verification successful: getProblemsByGrade filters by grade correctly.");
  });

  await t.step("Test: getProblemsByGrade - no problems found", async () => {
    console.log("\n--- Testing getProblemsByGrade (No Results) ---");
    const nonExistentGrade = "V100";
    const result = await problemConcept.getProblemsByGrade({
      grade: nonExistentGrade,
    });
    console.log("Result for non-existent grade:", result);
    assertEquals(
      (result as { problems: any[] }).problems.length,
      0,
      "Should return an empty array for a grade with no problems.",
    );
    console.log("Verification successful: getProblemsByGrade returns empty for no match.");
  });

  await t.step("Test: getProblemsByGrade - validation errors", async () => {
    console.log("\n--- Testing getProblemsByGrade (Validation Errors) ---");
    const result = await problemConcept.getProblemsByGrade({ grade: "" });
    console.log("Result for empty grade string:", result);
    assertEquals(
      (result as { error: string }).error,
      "Grade cannot be empty.",
      "Expected error for empty grade.",
    );
    assertNotEquals(
      (result as { problems: any[] }).problems,
      undefined,
      "Should not return problems for invalid input.",
    );
    console.log("Verification successful: getProblemsByGrade handles validation errors.");
  });

  await t.step("Test: Principle fulfillment - Discover and attempt problems", async () => {
    console.log("\n--- Testing Principle Fulfillment ---");
    console.log(
      "Principle: after creating a problem on a board with specific holds and attributes, users can discover and attempt the problem based on its characteristics",
    );

    // Trace: 1. Create problems
    console.log("Trace Step 1: Creating multiple problems on different boards and grades.");
    const problem1Result = await problemConcept.createProblem({
      name: "Basic Warmup",
      grade: "V1",
      holds: ["J1", "J2", "J3"],
      board: boardAId,
      setter: userAliceId,
    });
    const problem1Id = (problem1Result as { problem: ID }).problem;
    assertExists(problem1Id, "Problem 1 should be created.");

    const problem2Result = await problemConcept.createProblem({
      name: "Techy Corner",
      grade: "V4",
      holds: ["K1", "K2", "K3", "K4"],
      board: boardAId,
      setter: userBobId,
    });
    const problem2Id = (problem2Result as { problem: ID }).problem;
    assertExists(problem2Id, "Problem 2 should be created.");

    const problem3Result = await problemConcept.createProblem({
      name: "Power Traverse",
      grade: "V4",
      holds: ["L1", "L2", "L3"],
      board: boardBId,
      setter: userAliceId,
    });
    const problem3Id = (problem3Result as { problem: ID }).problem;
    assertExists(problem3Id, "Problem 3 should be created.");

    // Trace: 2. Discover problems on a specific board
    console.log(`Trace Step 2: Discovering problems on Board '${boardAId}'.`);
    const boardAProblems = await problemConcept.getProblemsByBoard({ board: boardAId });
    assertNotEquals((boardAProblems as { error: string }).error, undefined, "Expected no error.");
    assertEquals(
      (boardAProblems as { problems: any[] }).problems.length,
      4, // (Crimpy Traverse, Slabby Balancy, Basic Warmup, Techy Corner)
      `Expected 4 problems on board ${boardAId}.`,
    );
    const problemNamesBoardA = (boardAProblems as { problems: any[] }).problems.map((p) => p.name);
    console.log(`Found problems on Board A: ${problemNamesBoardA.join(", ")}`);
    assertExists(problemNamesBoardA.includes("Basic Warmup"), "Basic Warmup should be discoverable on boardA.");
    assertExists(problemNamesBoardA.includes("Techy Corner"), "Techy Corner should be discoverable on boardA.");
    assertNotEquals(problemNamesBoardA.includes("Power Traverse"), true, "Power Traverse should NOT be on boardA.");

    // Trace: 3. Discover problems by grade
    console.log("Trace Step 3: Discovering problems with Grade 'V4'.");
    const v4Problems = await problemConcept.getProblemsByGrade({ grade: "V4" });
    assertNotEquals((v4Problems as { error: string }).error, undefined, "Expected no error.");
    assertEquals(
      (v4Problems as { problems: any[] }).problems.length,
      2, // (Techy Corner, Power Traverse)
      "Expected 2 problems with grade V4.",
    );
    const problemNamesV4 = (v4Problems as { problems: any[] }).problems.map((p) => p.name);
    console.log(`Found problems with Grade V4: ${problemNamesV4.join(", ")}`);
    assertExists(problemNamesV4.includes("Techy Corner"), "Techy Corner should be discoverable by grade V4.");
    assertExists(problemNamesV4.includes("Power Traverse"), "Power Traverse should be discoverable by grade V4.");

    console.log("Principle fulfillment demonstrated: Problems are created and can be discovered by board and grade.");
  });

  await client.close();
});
```
